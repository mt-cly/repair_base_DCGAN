import cv2
import numpy as np
import os
import configparser as cfg_parser

cp = cfg_parser.ConfigParser()
cp.read('net.cfg')

read_path = cp.get('file', 'read_path')
target_path = cp.get('file', 'target_path')
save_path = cp.get('file', 'save_path')
result_path = cp.get('file', 'result_path')
repair_path = cp.get('file', 'repair_path')
model_path = cp.get('file', 'model_path')
image_height = cp.getint('image', 'image_height')
image_width = cp.getint('image', 'image_width')
image_depth = cp.getint('image', 'image_depth')


def get_imgs(size):
    """
    get imgs from given path of data, the range of data is [0, 1] but not [0, 255] or [-1, 1]
    :param size:  how many images would you wanna get (for training)
    :return: 
     list_img: a list contains images
    """
    list_img = []
    item = 0
    imgs_path = os.listdir(read_path)
    for img_path in imgs_path:
        img_path = read_path + img_path
        img = cv2.imread(img_path)
        # 投影至[0,1]
        img = img / 255
        list_img.append(img)
        item += 1
        if item == size or item == len(img_path):
            list_img = np.array(list_img)
            # Samples are not many, we can use normalization optional
            # list_img = MinMaxScaler().fit_transform(list_img)
            return list_img


def get_target_img():
    """
    get the message about image and the region prepared to repair. the range of img has been reflected to [-1, 1] here.
    :return: 
     img: the image prepared to repair
     repair: a list shows the regions prepared to repair in img, with [[begin, end], [begin, end], ...] 
    """
    img = cv2.imread(target_path)
    img = img/255
    img = img * 2 - 1
    repair = []
    for i in range(3):
        repair.append([(15 + i) * 64 + 20, (15 + i) * 64 + 30])
    return img, repair


def plot_images(epoch_time, samples):
    """
    Save the images generated by G 
    :param epoch_time: G has finished several epoch.
    :param samples: A number of images wanted to generate
    :return: 
    """
    # [-1 ,1] to [0 ,1]
    samples = (samples + 1) / 2
    index = 0
    for img in samples:
        cv2.imwrite(result_path + 'img_' + str(epoch_time) + '_' + str(index) + '.jpg', img * 255)
        index += 1


def clip_mp4():
    """
    Help you to divide a video to each frame and save part of them.
    :return: 
    """
    cap = cv2.VideoCapture("#########.avi")
    i = 0
    while True:
        success, frame = cap.read()
        if success:
            if i % 6 == 0:
                cv2.imwrite("./data_1/" + str(i//6) + ".jpg", frame[70:690, 0:540])
            i += 1
        else:
            break


def change_imgs_size():
    """
    Resize the image to 64 x 64, to match the shape of input of D, this function should be called in preparation
    :return: 
    """
    num_imgs = 1000
    list_img = get_imgs(num_imgs)
    index = 0
    for img in list_img:
        img = cv2.resize(img, (image_height, image_width))
        cv2.imwrite(save_path + str(index) + ".jpg", img * 255)
        index += 1

